{
    "contents" : "# 150120 - R-function for doing backward elimination using a False Discovery Rate based penalty\n# Original reference to criteria for adaptive model selection:\n# Abramovich, F., Benjamini, Y., & Donoho, D. L. (2006). Special Invited Lecture: Adapting to Unknown Sparsity by Controlling the False Discovery Rate on JSTOR. The Annals of ….\n#\n# and how it functions in Backward Elimination:\n# Gavrilov, Y., Benjamini, Y., & Sarkar, S. K. (2009). JSTOR: The Annals of Statistics, Vol. 37, No. 2 (Apr., 2009), pp. 619-629. The Annals of Statistics.\n#\n# Code copied from presentation by Tal Galili available on \n# http://www.r-project.org/conferences/useR-2009/slides/Galili+Gavrilov+Benjamini.pdf\n# and adapted by Örjan Carlborg for use in a Backward Elimination setting\n#\n# Call the function as follows:\n# fit1 <- BEFDR( minimal.lm = lm.1, maximal.lm = lm.m, FDR.q = 0.05)\n# summary(fit1)\n\nBEFDR <- function(minimal.lm, maximal.lm, FDR.q=0.05, mfactor=2){\n  #This function remains the same for FS & BE\n  compute.Lambda<-function(k, m, Q=0.05) {i<-c(1:k)\n                                          return( (1/(k+1)) *\n                                                    sum(qnorm((Q/2) * (i/(m+1-i*(1-Q))))^2))  }\n  \n  #This function remains the same for FS & BE  \n  get.model.size <- function(a.lm) {require(MASS);\n                                    return(extractAIC(a.lm)[1]-1) }\n\n  require(MASS);\n\n  #Scope remains the same for FS & BE\n  the.scope <- list(lower = minimal.lm, upper = maximal.lm)\n  # Size of maximal.lm multiplied by mfactor \n  # as BE procedure is initiated when 1/mfactor of all the genotyped regions are already removed\n  # need to correct for all the tests that are actually performed when building\n  # the final model\n  m <- mfactor*get.model.size(maximal.lm) \n  new.model.size <- get.model.size(maximal.lm)\n  for (i in 1:m)\n  {\n    #test i <- 3\n    old.model.size <- new.model.size\n    Lambda <- compute.Lambda(k = old.model.size-1, m, Q = FDR.q)\n    \n    new.model <- stepAIC(maximal.lm, direction=\"backward\", scope=the.scope, k=Lambda, trace=-1)\n    new.model.size <- get.model.size(new.model);\n    \n    if (new.model.size >= old.model.size) break;\n  }\n  new.lm <- lm(new.model)\n  return(new.lm) }\n\nBEFDR_trait <- function(phenotype,mrks,FDR=5,mfactor=1){\n  modelfactor <- mfactor\n  xnam <- paste(\"as.numeric(geno_a[,\", mrks,\"])[-de]\", sep=\"\")\n  fmla <- as.formula(paste(\"phenotype ~ fx1[-de] +\", paste(xnam, collapse= \"+\")))\n  be.lm <- lm(fmla, y=TRUE)\n  min.lm <- lm(phe[-de] ~ fx1[-de])\n  \n  if (FDR < 10) {\n    fit <- BEFDR( minimal.lm = min.lm, maximal.lm = be.lm, FDR.q = 0.05,mfactor=modelfactor)    \n  } else if (FDR > 10){\n    #Perform Backward-Elimination in the original data at different adaptive FDR thresholds\n    fit <- BEFDR( minimal.lm = min.lm, maximal.lm = be.lm, FDR.q = 0.20,mfactor=modelfactor)    \n  }\n  return(fit)\n}\n\nsummarize_BE <- function(fitFDR){\n  mrksFDR <- fitted_mrks(fitFDR)\n  Markers_BE_FDR <- matrix(data=NA, nrow=(length(mrksFDR)-1),ncol=12)\n  Markers_BE_FDR[,1] <- mrksFDR[2:length(mrksFDR)]\n  Markers_BE_FDR[,2:4] <- mrks_info[mrksFDR[2:length(mrksFDR)],1:3] #Remove first element in model as this is sex\n  Markers_BE_FDR[,2] <- as.character(Markers_BE_FDR[,2])\n  Markers_BE_FDR[,3] <- as.numeric(Markers_BE_FDR[,3])\n  Markers_BE_FDR[,4] <- as.numeric(Markers_BE_FDR[,4])/1000000\n  Markers_BE_FDR <- as.data.frame(Markers_BE_FDR, stringsAsFactors=FALSE)\n  FDRfit <- summary(fitFDR)\n  Markers_BE_FDR[,5:7] <- get_estimates(Markers_BE_FDR,FDRfit,\"O\",Markers_BE_FDR[,5:7])\n  colnames(Markers_BE_FDR)[1:7]<-c(\"Marker.id\",\"Marker.name\",\"Chromosome\",\"MbGG4\",\"Mean OM\",\"SE OM\",\"p-value OM\")\n  return(Markers_BE_FDR)\n}\n\n# Function for obtaining Cross-validation MSE\nlibrary(DAAG)\nk_fold_mse <- function(lmfit, ngroup=2, data, reps=5) {\n  ms <- c()\n  for (i in 1:reps){\n    cvres <- CVlm(df=data, lmfit, m=ngroup, seed=30*i,print=FALSE) # two-fold cross validation \n    ms[i]<-attr(cvres, \"ms\")  \n  }\n  meanms <- mean(ms)\n  return(meanms)\n}\n\n# Function for calculating R2 using replicates of k-fold Cross-Valiation\nlibrary(bootstrap)\nk_fold_rsq_r <- function(lmfit, ngroup=2, data, reps=5) {\n  rsq <- c()\n  for (i in 1:reps){\n    cvr2res <- k_fold_rsq(lmfit, ngroup)\n    rsq[i]<-cvr2res[2]\n  }\n  meanrsq <- mean(rsq)\n  return(meanrsq)\n}\n\nk_fold_rsq <- function(lmfit, ngroup=10) {\n  # assumes library(bootstrap)\n  # adapted from http://www.statmethods.net/stats/regression.html\n  mydata <- lmfit$model\n  outcome <- names(lmfit$model)[1]\n  predictors <- names(lmfit$model)[-1]\n  \n  theta.fit <- function(x,y){lsfit(x,y)}\n  theta.predict <- function(fit,x){cbind(1,x)%*%fit$coef} \n  X <- as.matrix(mydata[predictors])\n  y <- as.matrix(mydata[outcome]) \n  \n  results <- crossval(X,y,theta.fit,theta.predict,ngroup=ngroup)\n  raw_rsq <- cor(y, lmfit$fitted.values)**2 # raw R2 \n  cv_rsq <- cor(y,results$cv.fit)**2 # cross-validated R2\n  \n  c(raw_rsq=raw_rsq, cv_rsq=cv_rsq)\n}\n\n# Bootstrap-function returning fitted markers after Backward-Elimination based on adaptive FDR criterion\n\nboot_befdr <- function(maximalbs.lm, minimalbs.lm, FDRBS.q) {\n  fitFDRBS <- BEFDR( maximal.lm = maximalbs.lm, minimal.lm = minimalbs.lm, FDR.q = FDRBS.q)\n  # Extract markers fitted in final model\n  fitFDRBS.sum<-summary(fitFDRBS)\n  tmp <- fitFDRBS.sum$aliased\n  tmp <- as.matrix(tmp)\n  tmp2 <- rownames(tmp)\n  as.numeric(gsub(\"([0-9]+).*$\", \"\\\\1\", tmp2))\n  temp1 <- gregexpr(\"[0-9]+\", tmp2)\n  regmatches(tmp2,temp1)\n  fitted.mrks<-as.numeric(unlist(regmatches(tmp2, temp1)))\n  return(fitted.mrks)\n}\n\nfitted_mrks <- function(model.lm) {\n  model.sum<-summary(model.lm)\n  tmp <- model.sum$aliased\n  tmp <- as.matrix(tmp)\n  tmp2 <- rownames(tmp)\n  as.numeric(gsub(\"([0-9]+).*$\", \"\\\\1\", tmp2))\n  temp1 <- gregexpr(\"[0-9]+\", tmp2)\n  regmatches(tmp2,temp1)\n  model.mrks<-as.numeric(unlist(regmatches(tmp2, temp1)))\n  return(model.mrks)\n}\n\n# Function for creading a new model formula for hGLM Backward-Elimination by removing given markers\nget_estimates <- function(Markers,lm.object,type,results){\n  m <- lm.object\n  if (type==\"O\"){ #Original data\n    est<-m$coefficients[which(rownames(m$coefficients)%in%paste(\"as.numeric(geno_a[, \", Markers[,1],\"])[-de]\", sep=\"\")),1]\n    SE<-m$coefficients[which(rownames(m$coefficients)%in%paste(\"as.numeric(geno_a[, \", Markers[,1],\"])[-de]\", sep=\"\")),2]\n    sign<-m$coefficients[which(rownames(m$coefficients)%in%paste(\"as.numeric(geno_a[, \", Markers[,1],\"])[-de]\", sep=\"\")),4]    \n    \n  } else { #Bagging\n    est<-m$coefficients[which(rownames(m$coefficients)%in%paste(\"as.numeric.geno_a...\", Markers[,1],\"....de.\", sep=\"\")),1]\n    SE<-m$coefficients[which(rownames(m$coefficients)%in%paste(\"as.numeric.geno_a...\", Markers[,1],\"....de.\", sep=\"\")),2]\n    sign<-m$coefficients[which(rownames(m$coefficients)%in%paste(\"as.numeric.geno_a...\", Markers[,1],\"....de.\", sep=\"\")),4]    \n  }\n  results[,1]<-as.numeric(est)\n  results[,2]<-as.numeric(SE)\n  results[,3]<-as.numeric(sign)\n  return(results)\n}\n\n# Function to test for collinearity in regression model using VIF and Quote betwen Max/Min Eigenvalues\ntest_collinearity <- function(lm.model){\n  coll_model<-c()\n  \n  #Greater than 10 = severe\n  vif_model <- vif(lm.model)\n  \n  #Greater than 30 indicates poor condition number and consequently strong collinearity  \n  X <- model.matrix(lm.model)\n  eig <- eigen(crossprod(X))\n  eig_quote<-(max(eig$values)/min(eig$values)) \n  coll_model<-c(vif_model,eig_quote)  \n  return(coll_model)\n}\n\n# Function for creading a new model formula for hGLM Backward-Elimination by removing given markers\nbe_function <- function(all_mrks,elim_mrks,fmla){\n  markers <- all_mrks\n  eliminated <- elim_mrks\n  kept <- !(markers%in%eliminated)\n  xnam <- paste(\"as.numeric(geno_a_all[,\", markers[kept],\"])[-de]\", sep=\"\")\n  fmla <- as.formula(paste(\"~ fx1[-de] +\", paste(xnam, collapse= \"+\")))\n  return (fmla)\n}\n\n\n\n# Original forward-selection function\n# Obtained from presentation by Tal Galili available on http://www.r-project.org/conferences/useR-2009/slides/Galili+Gavrilov+Benjamini.pdf\n# Based on the paper:\n# Benjamini, Y., & Gavrilov, Y. (2009). A simple forward selection procedure based on false discovery rate control. \n#The Annals of Applied Statistics, 3(1), 179–198.\nMSFDR <- function(minimal.lm, maximal.lm, FDR.q=0.05){\n  compute.Lambda<-function(k, m, Q=0.05) {i<-c(1:k)\n                                          return( (1/(k+1)) *\n                                                    sum(qnorm((Q/2) * (i/(m+1-i*(1-Q))))^2))  }\n  get.model.size <- function(a.lm) {require(MASS);\n                                    return(extractAIC(a.lm)[1]-1) }\n  require(MASS);\n  the.scope <- list(lower = minimal.lm, upper = maximal.lm)\n  m <- get.model.size(maximal.lm)\n  new.model.size <- get.model.size(minimal.lm)\n  for (i in 1:m)\n  {\n    old.model.size <- new.model.size\n    Lambda <- compute.Lambda(k = old.model.size+1, m, Q = FDR.q)\n    \n    new.model <- stepAIC(minimal.lm, direction=\"forward\", scope=the.scope, k=Lambda, trace = F)\n    new.model.size <- get.model.size(new.model);\n    \n    if (new.model.size <= old.model.size) break;\n  }\n  return(new.lm) }\n\n\n",
    "created" : 1484822113798.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2567324202",
    "id" : "422FC697",
    "lastKnownWriteTime" : 1424694511,
    "path" : "~/Google Drive/HL_AIL_F15/bin/150121_OCG_RFunctions_HLAILF15.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 8,
    "source_on_save" : false,
    "type" : "r_source"
}